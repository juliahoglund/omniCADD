---
title: "Summary statistics of simulated variants and extractred ancestral sequences"
output:
  html_document:
    df_print: paged
date: "`r Sys.Date()`"
params: 
  tree: 'data/step_3/43_eutherian_mammals_EPO_default.nh'
  ideogram: 'data/indexfile.txt'
  annotation: 'data/step_3/CDS.regions.bed'
  bedfile: 'data/step_3/Ancestor.bed'
  coverage: 'data/step_3/coverage.CDS.bed'
  # lower case only!!
  ingroup: 'sus scrofa'
  # lower case only!!
  outgroup: 'bos taurus'
  path: '~/Documents/localCADD/'
  
---

```{r setup, include = FALSE}

# https://hgdownload.soe.ucsc.edu/downloads.html 
# ftp://hgdownload.soe.ucsc.edu/goldenPath

list.of.packages <- c("ggfittext", "patchwork", "ggplotify", "gridExtra", "BiocManager", "kableExtra", "ape", "ggpubr", "knitr", "gtools", "ggtext", "RIdeogram", "imager")
list.of.bioconductor <- c("biomaRt", "chromPlot", "GenomicFeatures", "BSgenome", "ggtree", "emojifont")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos = "http://cran.us.r-project.org")

new.bioconductor <- list.of.bioconductor[!(list.of.bioconductor %in% installed.packages()[,"Package"])]
if(length(new.packages)) BiocManager::install(new.bioconductor, force = TRUE)

library(tidyverse)
library(tidytree)
library(data.table)
library(ggfittext)
library(gridExtra)
library(patchwork)
library(ggplotify)
library(knitr)
library(kableExtra)
library(ggtree)
library(biomaRt)
library(chromPlot)
library(GenomicFeatures)
library(ape)
library(grid)
library(emojifont)
library(ggpubr)
library(gtools)
library(ggtext)
library(RIdeogram)
library(imager)
load.fontawesome()

rm(list = )
load(paste(params$path, "graphs.RData", sep = ""))
```

# Variant simulator; report
### Node used for reconstructing ancestral genome sequence

If a (newick) phylogenetic tree file has been provided, the visualisation of the MSA used in the calculations is shown below. The two chosen groups (i.e. 'ingroup' / species of interest, and outgroup) are highlighted in the tree. The outgroup, used in the computation or not, is the outgroup, which together with the reference species of interest coalesce at the node of interest, from which the ancestral sequence have been extracted. Most recent common ancestor (MRCA) is highlighted in purple and labeled. The rest of the clades in the alignment are shown in lighter grey. Regardless whether a reconstructed ancestral sequence at a node, or an outgroup, has been chosen as the ancestor, the MRCA will be highlighted.

```{r generate tree, include = FALSE}

### if no tree file, print not available

if (params$tree == 'None') {

  text <- text_grob("[no phylo tree available]", face = "bold", color = "grey55", just = "bottom", size = 30)
  code <- ggplot() + geom_emoji("herb", color='grey', size = 50) + theme_void() +
    theme(legend.position="none",
          plot.margin=unit(c(-0.5,1,1,1), "cm"))
  
  phylogenetic.tree <- as.ggplot(grid.arrange(text, code))
  
} else {
  tree <- read.tree(paste(params$path, params$tree, sep=""))
  tree
  
  for (i in 1:length(tree$tip.label)) {
    tree$tip.label[i] <- tolower(paste(unlist(str_split(tree$tip.label[i], "_"))[1:2], collapse = ' '))
  }
  
  ancNode <- getMRCA(tree, c(params$ingroup, params$outgroup))
  ingroup <- parent(tree, which(tree$tip.label == params$ingroup))
  outgroup <- parent(tree, which(tree$tip.label == params$outgroup))

  clade <- c("ancestor" = ancNode, "ingroup" = ingroup, "outgroup" = outgroup)
  tree <- groupClade(tree, clade)
  data <- data.frame(id = c(ancNode, ingroup, outgroup),
                     annote = c("clade in \nancestral node", "ingroup", "outgroup"),
                     offset = c(0.05, 0.03, 0.03),
                     offset.text = c(0.15, 0.15, 0.15))
  
  p <- ggtree(tree) + hexpand(.4)
  selected_nodes <- offspring(p, ancNode)$node
  
}

#################
```

```{r print tree, echo=FALSE, warning = FALSE, fig.width = 13, fig.height = 7}

if (params$tree == 'None') {
  phylogenetic.tree
} else {
  # Generate
  phylogenetic.tree <- 
    p + 
    geom_text(aes(label = label), 
              data = td_filter(isTip & node %in% selected_nodes), 
              hjust = 0, 
              fontface = 3) + 
    geom_nodepoint(aes(subset = node == ancNode), 
                   size=5, 
                   color='purple') +
    geom_nodelab(aes(label = "most recent common ancestor", subset = node == ancNode),
                 geom = 'label',
                 color = 'purple',
                 hjust = 1.2) +
    geom_cladelab(data=data, 
                  mapping=aes(node=id, label=annote, offset=offset),
                  barcolor = "darkgrey", 
                  textcolor = "black", 
                  barsize = 3.2, 
                  fontsize = 3, 
                  fontface = 2, 
                  align = TRUE) +
    geom_hilight(data = data[2:3,],
                 mapping = aes(node = id),
                 alpha = 0.2,
                 extendto = 1.9) + 
    geom_tree(aes(color=group))+
    scale_color_manual(values=c("darkgrey","black", "darkgreen", "maroon")) +
    theme(legend.position = "none")
  
  fig_legend <- plot_annotation(
  caption = "**Figure 1.** <br>
  Phylogenetic representation of the nodes and leaves used in the extraction of a 
  recontructed ancestral sequence or an outgroup.
  The two branches in which the ingroup (*reference species*) and outgroup (or branch used to calculate the
  <span style = 'color:#8432AD;'>most recent common ancestor</span> (**MRCA**), are <span style = 'color:#C7D7E6;'>highlighted</span>.
  The branch containing the species of interest is marked in <span style = 'color:#055636;'>green</span>, 
  and the one containing the outgroup in <span style = 'color:#8E2250;'>maroon</span>.",
  theme = theme(
    plot.caption = element_textbox_simple(
      size = 14,
      box.colour = "black",
      linetype = 2,
      padding = unit(c(7, 7, 7, 7), "pt"),
      r = unit(3, "pt"))))
  # print
  phylogenetic.tree + fig_legend
  }

```

### Distribution of simulated variants across the reference genome
If an ideogram (often possible to download on the UCSC website, [here](https://genome.ucsc.edu/cgi-bin/hgTables)) has been provided, the distribution of simulated variants is shown across the genome of the species of interest. The grey distribution corresponds to the total amount of simulated variants, whereas the red distribution corresponds to the subset that is overlapping with a corresponding non-gap ancestral sequence. 
If there is no forced sub-sampling due to lack of ancestral sequence, the distribution will be fully red. 

```{r genome distribution, echo = FALSE, include = FALSE}

if (params$ideogram == 'None') {

  text <- text_grob("[no ideogram information available]", face = "bold", color = "grey55", just = "bottom", size = 30)
  code <- ggplot() + geom_emoji("paw_prints", color='grey', size = 80) + theme_void() +
    theme(legend.position="none",
          plot.margin=unit(c(-0.5,1,1,1), "cm"))
  
  chromPLOT <- as.ggplot(grid.arrange(text, code))
  
} else {
  # fix data
  
  sscr_ideoGram <- fread(paste(params$path, params$ideogram, sep="")) %>% 
    dplyr::rename("Chrom" = "V1", "Start" = "V2", "End" = "V3") %>%
    makeGRangesFromDataFrame(.) 
  
  SimVars <- simulatedSNPs %>%
    dplyr::rename("Chrom" = "CHROM", "Start" = "POS") %>%
    dplyr::select(Chrom, Start, ALT) %>%
    mutate(End = Start) %>% 
    relocate(ALT, .after = End)
  
  OverlapVars <- simulatedAncestorSNPs %>%
    dplyr::rename("Chrom" = "CHROM", "Start" = "POS") %>%
    dplyr::select(Chrom, Start, ALT) %>%
    mutate(End = Start) %>% 
    relocate(ALT, .after = End)
}

```

```{r plot distribution, fig.width = 13, fig.height = 14, echo = FALSE}
# plot data
# Here's a nice function for suppressing output from cat() by Hadley Wickham:

quiet <- function(x) { 
  sink(tempfile()) 
  on.exit(sink()) 
  invisible(force(x)) 
}

if (params$ideogram == 'None') {
  chromPLOT
} else {
  
  quiet(
  chromPlot(bands = sscr_ideoGram, 
            figCols = 4, 
            annot1 = SimVars,
            annot2 = OverlapVars,
            colAnnot1 = "#bababa",
            colAnnot2 = "tomato",
            # bin = base on genome size!
            chr = stats$chromosome)
  )
  }

```

```{r figure 1 legend, fig.width = 12, fig.height = 2, echo = FALSE}
if (params$ideogram == 'None') {
  skip = 1
  } else {
    df <- data.frame(
    x = 1, y = 1, label = paste( "**Figure 2.** <br>
  chromPlot showing the karyogram of the species of interest from chromosome 1:N and sex chromosome (if applicable). The chromosome number is shown above each chromosome. <span style = 'color:#bababa;'>The count (per bin)</span> of total simulated variants are shown in <span style = 'color:#bababa;'>grey</span>. <span style = 'color:#fa5545;'>The count (per bin)</span> of simulated variants that are overlapping with a corresponding non-gap ancestral sequence, i.e, that are not located within an ancetral gap, are shown in <span style = 'color:#fa5545;'>red</span>. This graph aims to show the overall distribution of simulated variants within the full reference genome against the parts that are aligning to an available ancestral sequence."))
  text <-  
    ggplot(df) +
    ggtext::geom_textbox(aes(x = x, y = y, label = label), width = unit(700, "pt"), box.margin = margin(0,0,0,0, "pt")) +
    theme_void() 
  
  text
  }
```


### How much of the reference genome that has an available, aligned reconstructed ancestral sequence
```{r genome fractions, echo = FALSE}
# make table
COVER <- 
  data.frame(Chromosome = stats$chromosome,
             A = stats$srcSize,
             B = stats$size.ancestor,
             C = stats$frac.covered
             ) %>% 
    arrange_all() %>% 
    column_to_rownames(var = "Chromosome") %>%
    mutate(C = round(C, digits = 2)) %>%
    dplyr::rename("Size of ref. genome" = "A", 
         "Size of reconstructed genome" = "B",
         "Fraction covered of ref. genome" = "C")

kable(COVER, format = "pipe", align = 'r', format.args = list(big.mark = " "), caption = "**Table 1**\nFraction of refence genome that has an available aligned reconstructed ancestral sequence. The leftmost column represents the total size of the source chromosome (in base pairs), from the species of interest. The middle column represents the size (in base pairs) of the recontructed ancestral genome (or size of aligned outgroup without gaps). The rightmost column represents the fraction of the reference genome that is covered by an ancestral sequence, i.e. the fraction of the reference with a corresponding non-gap ancestral alignment.")

```


### Number of simulated variants
##### and how many are overlapping with an available ancestral sequence


```{r snp fractions, echo=FALSE, fig.width = 11, fig.height = 8, fig.align = 'center'}
fraction.used <- 
  simulatedSNPs %>% 
  count(CHROM, FORMAT) %>%
  group_by(CHROM) %>%
  mutate(pct=n/sum(n))

fraction.used$CHROM <- factor(fraction.used$CHROM, levels = str_sort(factor(unique(fraction.used$CHROM)), numeric = TRUE))

fraction.plot <- 
  ggplot(data = fraction.used, aes(CHROM, n, fill=FORMAT)) +
  geom_bar(stat="identity") +
  labs(y= "count", x = "chromosome") +
  scale_fill_manual(name = "overlap", values=c('#d3bcc0', '#8f7a8a')) +
  ggtitle("fraction of simulated variants with a corresponding non-gap position in ancestral sequence") +
  ggfittext::geom_bar_text(aes(label=paste0(sprintf("%1.1f", pct*100),"%")), color = "#333e3d", position = "stack", reflow = TRUE) +
  theme_classic()

fig_legend <- plot_annotation(
  caption = "**Figure 3.** <br>
  Stacked barplot depicting how many of the simulated variants are in a position with an aligned non-gap ancestral sequence. Total count of variants is on the Y axis and the chromosome on the X axis. <span style = 'color:#8f7a8a;'>Overlapping variants</span> is the fraction (percentage) that has an aligned ancestral sequence and <span style = 'color:#d3bcc0;'>non-overlapping variants</span> are located within a gap in the ancestral sequence.",
  theme = theme(
    plot.caption = element_textbox_simple(
      size = 14,
      box.colour = "black",
      linetype = 2,
      padding = unit(c(7, 7, 7, 7), "pt"),
      margin = unit(c(10,10,10,10), "pt"),
      r = unit(3, "pt"))))

# print
fraction.plot + fig_legend

```

##### Table with corresponding data:

```{r SNP table, echo=FALSE}
# make table
SNPS <- 
  data.frame(Chromosome = stats$chromosome,
             A = stats$no.variants,
             B = stats$no.SNPs,
             C = stats$frac.SNPs,
             D = stats$frac.SNPs.filtered
  ) %>% 
  arrange_all() %>%
  column_to_rownames(var = "Chromosome") %>%
  mutate(C = round(C, digits = 2),
         D = round(D, digits = 2)) %>%
  dplyr::rename("Number of simulated variants" = "A", 
         "No of sim. SNPs" = "B",
         "Fraction of simulated SNPs" = "C",
         "Fraction of sim. SNPs overlapping ancestral seq." = "D")


kable(SNPS, format = "pipe", align = 'r', format.args = list(big.mark = " "), caption = "**Table 2**.<br>Fraction of simulated SNPs that is overlapping with a reconstructed ancestral sequence. Column explanation from left to right: <br> **i)** chromosome number<br> **ii)** the total number of simulated variants <br> **iii)** the total number of simulated SNPs (i.e. excluding indels) <br> **iv)** the fraction of simulated SNPs <br> **v)** the fraction of simulated SNPs that are overlapping with a non-gap align recontructed ancestral sequence.")

```

### Types of simulated mutations


```{r variant fractions, echo = FALSE, fig.width = 11, fig.height = 8}
mutation.types <- 
  simulatedAncestorSNPs %>% 
  count(CHROM, FILTER) %>%
  group_by(CHROM) %>%
  mutate(pct=n/sum(n))

mutation.types$CHROM <- factor(mutation.types$CHROM, levels = str_sort(factor(unique(mutation.types$CHROM)), numeric = TRUE))

mutation.plot <-             
  ggplot(data = mutation.types, aes(CHROM, n, fill=FILTER)) +
  geom_bar(stat="identity") +
  ggfittext::geom_bar_text(aes(label=paste0(sprintf("%1.1f", pct*100),"%")), color = "#333e3d", position = "stack", reflow = TRUE) +
  labs(y= "count", x = "chromosome") + 
  scale_fill_manual(name = "mutation type", values=c('#f2c975', '#b96d41', '#928674')) +
  ggtitle("Fractions of mutation types across the simulated variants, with an available ancestral sequence") +
  theme_classic()

fig_legend <- plot_annotation(
  caption = "**Figure 4.** <br>
  Stacked barplot depicting how many of the types of mutations (transitions, transversions, CpGs) across the simulated variants with an aligned non-gap ancestral sequence. Total count of variants is on the Y axis and the chromosome on the X axis. <span style = 'color:#f2c975;'>CpG mutations</span> are shown in <span style = 'color:#f2c975;'>yellow</span>, <span style = 'color:#b96d41;'>transitions</span> are shown in <span style = 'color:#b96d41;'>orange</span>, and <span style = 'color:#928674;'>transversions</span> are shown in <span style = 'color:#928674;'>brown</span>.",
  theme = theme(
    plot.caption = element_textbox_simple(
      size = 14,
      box.colour = "black",
      linetype = 2,
      padding = unit(c(7, 7, 7, 7), "pt"),
      margin = unit(c(10,10,10,10), "pt"),
      r = unit(3, "pt"))))

mutation.plot + fig_legend
```


##### Table with corresponding data:

```{r variant table, echo=FALSE}
# make table
ANC <- 
  data.frame(Chromosome = ancestorset$chromosome,
             A = ancestorset$no.SNPs,
             B = ancestorset$frac.transitions,
             C = ancestorset$frac.transversions,
             D = ancestorset$frac.CpGs,
             E = ancestorset$frac.nonCpGs
             ) %>%
  arrange_all() %>%
  column_to_rownames(var = "Chromosome") %>%
  mutate(B = round(B, digits = 2),
         C = round(C, digits = 2),
         D = round(D, digits = 2),
         E = round(E, digits = 2)) %>%
  dplyr::rename("No. of SNPs" = "A", 
         "Fraction transitions" = "B",
         "Fraction transversions" = "C",
         "Fraction CpGs" = "D",
         "Fraction non-CpGs (1-CpGs)" = "E")

kable(ANC, format = "pipe", align = 'r', format.args = list(big.mark = " "), caption = "**Table 3** <br> Fraction of mutation types across the simulated variants with an available corresponding ancestral sequence. Column explanation, starting from left: <br> **i)** chromosome number <br> **ii)** the total number of SNPs <br> **iii)** the fraction of transitions <br> **iv)** the fraction of transversions <br> **v)** the fraction of CpG site mutations <br> **vi)** the fraction of non-CpG mutations (transitions + transversions)")

```

### Visualisation of gene density
#### and CDS overlap
```{r gene density, echo = FALSE, warning = FALSE, fig.width = 11, fig.height = 8}

####################################
######## LOAD KARYOGRAM. ###########
#### (created in previous step) ####
####################################

karyogram <- read.table(paste(params$path, params$ideogram, sep=""), header = F)
karyogram <- 
  karyogram %>% 
  # change to desired number of chromosomes
  dplyr::rename('Chr' = 'V1', 'Start' = 'V2', 'End' = 'V3') %>%
  dplyr::select(Chr, Start, End) %>%
  # centromere data, needed even if absent
  mutate(CE_start = 0, CE_end = 0)

# sort chromosomes (is a hassle)
karyogram$Chr <- factor(karyogram$Chr, levels = str_sort(factor(unique(karyogram$Chr)), numeric = TRUE))
karyogram <- karyogram[order(karyogram$Chr),]
karyogram$Chr <- as.character(karyogram$Chr)

####################################
######  LOAD CDS BED FILE. #########
## (extracted from genomewide gff) #
####################################

if (params$annotation == "None") {
  
  message("annotation file not available.")
  
} else {
  
  suppressMessages({
  genes <- read.table(paste(params$path, params$annotation, sep=""), header=F)
  n <- 
    genes %>% 
    mutate(bins = cut(V2, breaks = 100)) %>% 
    group_by(V1) %>% 
    count(bins)
  
  range <-
    genes %>% 
    mutate(bins = cut(V2, breaks = 100)) %>% 
    group_by(V1, bins) %>% 
    summarise(minvalue = min(V2), maxvalue = max(V3)) %>% 
    dplyr::rename('chrom' = 'V1')
  })
  
  ref_genes <- data.frame(Chr = range$chrom,
                          Start = range$minvalue,
                          End = range$maxvalue,
                          Value = n$n)
  
  ref_genes$Chr <- factor(ref_genes$Chr, levels = str_sort(factor(unique(ref_genes$Chr)), numeric = TRUE))
  ref_genes <- ref_genes[order(ref_genes$Chr),]
  ref_genes$Chr <- as.character(ref_genes$Chr)

}

####################################
####  LOAD ancestor BED FILE. ######
#### (created with fasta2bed.py) ###
### concatenated to genome-wide ####
####################################

suppressMessages({
  ancestor <- read.table(paste(params$path, params$bedfile, sep=""), header=F)
  
  n <- 
    ancestor %>% 
    mutate(bins = cut(V2, breaks = 100)) %>% 
    group_by(V1) %>% 
    count(bins)
  
  range <- 
    ancestor %>% 
    mutate(bins = cut(V2, breaks = 100)) %>% 
    group_by(V1, bins) %>% 
    summarise(minvalue = min(V2), maxvalue = max(V3)) %>% 
    dplyr::rename('chrom' = 'V1')
})

ancestor_seqs <- data.frame(Chr = range$chrom,
                            Start = range$minvalue,
                            End = range$maxvalue,
                            Value = n$n)

ancestor_seqs$Chr <- factor(ancestor_seqs$Chr, levels = str_sort(factor(unique(ancestor_seqs$Chr)), numeric = TRUE))
ancestor_seqs <- ref_genes[order(ancestor_seqs$Chr),]
ancestor_seqs$Chr <- as.character(ancestor_seqs$Chr)

####################################
####  CREATE SEQ DENSITY PLOT ######
####################################

if (params$annotation == "None") {
  ideogram(karyotype = karyogram,
           overlaid = ancestor_seqs,
           colorset1 = c("#fff2ed", "#ffb296", "#ff7f50"),
           output = paste(params$path, "output/anc-seq.svg", sep=""))
  
    svg2png(svg = paste(params$path, "output/anc-seq.svg", sep=""), 
            file = 'anc-seq',
            width = 8, height = 8, dpi = 300)
    
    system(paste("mv ~/anc-seq.png ", params$path, "output/",  sep=""))
    
    myimg <- load.image(paste(params$path, "output/anc-seq.png", sep=""))
  
  df <- 
    as.data.frame(myimg, wide="c") %>% 
    mutate(rgb.val=rgb(c.1,c.2,c.3))
  
  karyo1 <- 
    ggplot(df, aes(x,y)) + 
    geom_raster(aes(fill=rgb.val)) + 
    theme_void() + 
    scale_fill_identity() + 
    scale_y_reverse()
  
  df <- data.frame(
      x = 1, y = 1, label = paste( "**Figure 5.** <br>
    Karyoplot depicting the <span style = 'color:#ff7f50;'>ancestor sequence density</span> across the genome of the reference species of interest. The chromosomes that have been used in the analysis (eg. autosomes only or autosomes + X) are depicted. The darker the color the higher the density. This figure shows the location / density of the reconstructed ancestral sequence(s).<br><br>**The high resolution version of this graph has been printed in the output folder.**"))
  
  text <-  
    ggplot(df) +
    ggtext::geom_textbox(aes(x = x, y = y, label = label), 
                         width = unit(700, "pt"), 
                         box.margin = margin(0,0,0,0, "pt")) +
    theme_void()
  
  layout <- c(
    area(1,1,3,2),
    area(3,1,3,2)
  )
  
  karyo1 + text + 
    plot_layout(design = layout)
    
} else {
  ideogram(karyotype = karyogram, 
           overlaid = ref_genes, 
           label = ancestor_seqs, 
           label_type = "heatmap", 
           colorset1 = c("#efe5ef", "#a366a3", "#660066"),
           colorset2 = c("#fff2ed", "#ffb296", "#ff7f50"),
           output = paste(params$path, "output/anc-seq.svg", sep=""))
  
  svg2png(svg = paste(params$path, "output/anc-seq.svg", sep=""), 
             file = "anc-seq", 
             width = 8, height = 8, dpi = 300)
  
  system(paste("mv ~/anc-seq.png ", params$path, "output/",  sep=""))
  
  myimg <- load.image(paste(params$path, "output/anc-seq.png", sep=""))
  
  df <- 
    as.data.frame(myimg, wide="c") %>% 
    mutate(rgb.val=rgb(c.1,c.2,c.3))
  
  karyo1 <- 
    ggplot(df, aes(x,y)) + 
    geom_raster(aes(fill=rgb.val)) + 
    theme_void() + 
    scale_fill_identity() + 
    scale_y_reverse()
  
  df <- data.frame(
      x = 1, y = 1, label = paste( "**Figure 5.** <br>
    Karyoplot depicting the <span style = 'color:#660066;'>gene density</span> and the <span style = 'color:#ff7f50;'>ancestor sequence density</span> across the genome of the reference species of interest. The chromosomes that have been used in the analysis (eg. autosomes only or autosomes + X) are depicted. The darker the color the higher the density. This figure shows the overlap of coding sequences in the reference genome and the location / density of the reconstructed ancestral sequence(s).<br><br>**The high resolution version of this graph has been printed in the output folder.**"))
  
  text <-  
    ggplot(df) +
    ggtext::geom_textbox(aes(x = x, y = y, label = label), 
                         width = unit(700, "pt"), 
                         box.margin = margin(0,0,0,0, "pt")) +
    theme_void()
  
  layout <- c(
    area(1,1,3,2),
    area(3,1,3,2)
  )
  
  karyo1 + text + 
    plot_layout(design = layout)

}

######################################
#####  LOAD coverage BED FILE. #######
# (bedtools coverage on genome wide) #
######################################

if (params$coverage == "None") {
  
  message("coverage file not available.")
  
} else {
  
  suppressMessages({
    overlap <- read.table(paste(params$path, params$coverage, sep=""), header=F)
    colnames(overlap) <- c("Chr", "Start", "End", "Depth", "BasesAtSite", "SizeOfA", "Value")
    overlap <- 
      overlap %>% 
      dplyr::select(Chr, Start, End, Value) %>% 
      # calculate bins based on size of chromosome later
      mutate(bins = cut(Start, breaks = 1000)) %>% 
      group_by(bins, Chr) %>% 
      summarise(minvalue = min(Start), maxvalue = max(End), overlap = mean(Value)) %>% 
      mutate(Color = "0a2e54") %>% 
      dplyr::select(Chr, minvalue, maxvalue, overlap, Color) %>% 
      dplyr::rename('Start' = 'minvalue', 'End' = 'maxvalue', 'Value' = 'overlap') %>% 
      as.data.frame(.)
  })
  
  overlap$Chr <- factor(overlap$Chr, levels = str_sort(factor(unique(overlap$Chr)), numeric = TRUE))
  overlap$Chr <- as.character(overlap$Chr)
  overlap <- overlap %>% arrange(Chr, Start) %>% dplyr::select(-bins)
  
}

####################################
####  CREATE SEQ COVERAGE PLOT #####
####################################

if (params$coverage == "None") {
  
  message("skipped last figure.")
  
} else {
  
  ideogram(karyotype = karyogram, 
         overlaid = ref_genes, 
         label = overlap, 
         label_type = "polygon", 
         colorset1 = c("#efe5ef", "#a366a3", "#660066"), 
         output = paste(params$path, "output/anc-coverage.svg", sep=""))
  
  svg2png(svg = paste(params$path, "output/anc-coverage.svg", sep=""), 
             file = "anc-coverage", 
             width = 8, height = 8, dpi = 300)
  
  system(paste("mv ~/anc-coverage.png ", params$path, "output/",  sep=""))
  
  myimg <- load.image(paste(params$path, "output/anc-coverage.png", sep=""))
  
  df <- 
    as.data.frame(myimg, wide="c") %>% 
    mutate(rgb.val=rgb(c.1,c.2,c.3))
  
  karyo2 <- 
    ggplot(df, aes(x,y)) + 
    geom_raster(aes(fill=rgb.val)) + 
    theme_void() + 
    scale_fill_identity() + 
    scale_y_reverse()
  
  df <- data.frame(
      x = 1, y = 1, label = paste( "**Figure 6.** <br>
    Karyoplot depicting the <span style = 'color:#660066;'>ancestor sequence density</span> across the genome of the reference species of interest. The chromosomes that have been used in the analysis (eg. autosomes only or autosomes + X) are depicted. The darker the color the higher the density. This figure shows the ancestral sequence density as bands and  the <span style = 'color:#0A2E54;'>blue</span> polygon data shows the coverage (in bins) of reconstructed ancestral sequences that is overlapping with coding sequences in the reference genome.<br><br>**The high resolution version of this graph has been printed in the output folder.**"))
  
  text <-  
    ggplot(df) +
    ggtext::geom_textbox(aes(x = x, y = y, label = label), 
                         width = unit(700, "pt"), 
                         box.margin = margin(0,0,0,0, "pt")) +
    theme_void()
  
  layout <- c(
    area(1,1,3,2),
    area(3,1,3,2)
  )
  
  karyo2 + text + 
    plot_layout(design = layout)
  
}


```


### Validation of simulation parameters
Number of mutations, fractions, and substitution rates.
To make sure the simulation was performed as expected, the leftmost part is the calculated numbers and rates in the parameter files, including the total number of simulated variants per chromosome, based on information from the ancestor and reference species. The middle part is the (re)calculated numbers and rates based on the total number of simulated variants. The rightmost part is the (re)calculated numbers and rates within the subset with a corresponding non-gap ancestral sequence. The comparison of parameters and simulated variants is to make sure that the simulation has been perform as intended, and the comparison between total set and the subset is to make sure that the distribution is the same even if the variants are forced to be down-sampled due to the lack of an available ancestral sequence.

```{r subst rates, echo = FALSE}
options(knitr.kable.NA = '')

colnames(substitutions) <- c(rep(' ', 9))
kbl(substitutions, caption = "Comparison of numebr of mutations between log files and actual simulated files") %>%
  kable_classic() %>%
  row_spec(c(seq(from = 1, to = nrow(substitutions), by = 21)), 
           bold = T, color = "#00688B", background = "#87CEEB") %>%
  row_spec(c(seq(from = 2, to = nrow(substitutions), by = 21), 
             seq(from = 15, to = nrow(substitutions), by = 21)), 
           bold = T, color = "#8B636C", background = "#FFC0CB") %>%
  row_spec(c(seq(from = 3, to = nrow(substitutions), by = 21), 
             seq(from = 6, to = nrow(substitutions), by = 21),
             seq(from = 9, to = nrow(substitutions), by = 21), 
             seq(from = 12, to = nrow(substitutions), by = 21),
             seq(from = 16, to = nrow(substitutions), by = 21), 
             seq(from = 19, to = nrow(substitutions), by = 21)), 
           bold = T, color = "#8B8386", background = "#FFF0F5") %>%
  add_header_above(c("Parameter files" = 3, "Simulated variant file" = 3, "Simulated variant file \n(filtered for positions with a corresponding non-gap ancestral position)" = 3))
 
```