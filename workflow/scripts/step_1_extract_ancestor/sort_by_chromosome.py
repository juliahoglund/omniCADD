#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
:Author: Christian Gross
:Contact: cgross@tudelft.nl
:Date: 30-01-2017
This script takes as input the path to the folder containing maf files
generated by a MSA pipeline such as the Ensembl EPO pipeline. Each file
will be read and then sorted and stored according to the sequence of interest
if available.
When finished all alignments with the sequence of interest are in the relevant
chromosome output file.

:Edited by: Job van Schipstal 
 :Date: 26-9-2023
:Example: python chr_sorting.py --species mm39 -i file1 ... file_n -o file...
- Removed redundant code, reformatted according to PEP8 guidelines.
- Accepts gzipped or lz4 compressed input or output files.
- Expects list of input and output files via argparse,
instead of searching for files in a given folder.

:Extension and modification: Julia HÃ¶glund
:Date: 31-10-2023
"""
# Import dependencies
import gzip
import re
import sys

from argparse import ArgumentParser
import lz4.frame

PARSER = ArgumentParser(description = __doc__)
PARSER.add_argument("-i", "--input",
                    help = "maf alignment file(s) which are to be sorted by chromosome", 
                    type = str, 
                    required = True, 
                    nargs = "+")
PARSER.add_argument("-o", "--output",
                    help = "Output alignment file(s), one per chr, has to end with chr[chr].maf(.gz|.lz4) ",
                    type = str, 
                    required = True, 
                    nargs = "+")
PARSER.add_argument("-s", "--species",
                    help = "name/label of the species by which the alignments should be sorted", 
                    "expected to be first in the sequence, ignored if not", 
                    type = str, 
                    required = True)
PARSER.add_argument("-l", "--logfile",
                    help = "logfile (default chr_sorting_log.txt)", 
                    type = str,
                    default = "chr_sorting_log.txt")
PARSER.add_argument("-p", "--prefix",
                    help = "prefix for chr in sequence label e.g. chr for mm39.chr19 (default None)", 
                    type = str, default = "None")


def create_outfile_dict(out_files: list) -> [dict, list]:
    """
    Extract chromosome from outfile and create dict of opened output files.
    :param out_files: list of str, file(path/name) to open
    :return: dict of key chrom, value output file handle, list of chromosomes
    """
    outfile_dict = {} 
    chroms = []
    for outfile in out_files:
        match = re.search(r"chr([a-zA-Z\d]+).maf(?:|.gz|.lz4)$", outfile)
        if not match:
            sys.exit(f"Invalid output file {outfile}, expected to end with chr[1].maf(.gz)")
        chrom = match.groups()[0]
        chroms.append(chrom)
        if outfile.endswith(".gz"):
            outfile_dict[chrom] = gzip.open(outfile, "wt")
        elif outfile.endswith(".lz4"):
            outfile_dict[chrom] = lz4.frame.open(outfile, mode = "wt")
        else:
            outfile_dict[chrom] = open(outfile, "w")
        outfile_dict[chrom].write("##maf version=1\n")
    return outfile_dict, chroms


def sort_alignments(file_h, species: str, prefix: str) -> None:
    """
    Iterate through alignment lines. Check if first sequence is of species
    of interest. If so store the alignment in the file for the chromosome of
    the species of interest. Discards alignments that do not contain the
    species of interest as the first sequence.
    :param file_h: file handle, to read alignments from
    :param species: str, species of interest label in alignments
    :param prefix: str, prefix in between sequence label and chr label
    :return: None, output written to files in OUTFILE_DICT
    """
    chrom = None
    for line in file_h:
        if line.startswith('a'):
            next_line = file_h.readline()
            if next_line.startswith(f"s {species}"):
                chrom = next_line.split()[1].split('.')[1]
                if chrom.startswith(prefix):
                    chrom = chrom[len(prefix):]
                if chrom not in CHROMOSOMES:
                    chrom = 'Other'
                OUTFILE_DICT[chrom].write(line)
                OUTFILE_DICT[chrom].write(next_line)
                continue
            chrom = None
        elif chrom:  # None if not to capture
            OUTFILE_DICT[chrom].write(line)


if __name__ == '__main__':
    ARGS = PARSER.parse_args()

    OUTFILE_DICT, CHROMOSOMES = create_outfile_dict(ARGS.output)

    with open(ARGS.logfile, "w") as log_f:
        log_f.write(f"Input files:\n{ARGS.input}\n"
                    f"Output files:\n{OUTFILE_DICT}\n")

    # Iterating over all files and opening them
    for infile in ARGS.input:
        if infile.endswith(".gz"):
            in_f = gzip.open(infile, "rt")
        elif infile.endswith(".lz4"):
            in_f = lz4.frame.open(infile, mode = "rt")
        else:
            in_f = open(infile, "w")
            
        # Iterating over the content of each file
        sort_alignments(in_f,
                        ARGS.species,
                        "" if ARGS.prefix == "None" else ARGS.prefix)
        in_f.close()

    for file in OUTFILE_DICT.values():
        file.close()
