#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""

# :Author: Martin Kircher
# :Contact: mkircher@uw.edu
# :Date: *09.05.2012
# :Reformatted by: Julia HÃ¶glund
# :Contact: julia.hoglund@su.se
# :Date: *21.11.2022
# :Reformatted by: Job van Schipstal
# :Contact: job.vanschipstal@wur.nl
# :Date: *27.09.2023

:Usage: see simulate_variants.py --help

This script simulates the variants, based on the parameters that have been
created with create_parameters.py and processed with process_parameters.py

The parameter processing functionality was split to process_parameters.py
"""

import os
import sys
from argparse import ArgumentParser
import random
import pickle
import gzip
import mmap  # allow for memory mapping
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

parser = ArgumentParser(description=__doc__)
parser.add_argument("-i", "--infile",
    help="Reference genome fasta file, plainfile with only 1 sequence, .fai index must also be present.",
    type=str, 
    required=True)
parser.add_argument("-c", "--chrom",
    help="Chromosome to generate variants for, without 'chr'",
    type=str, 
    required=True)
parser.add_argument("-p", "--pickle",
    help="Pickle file with the simulation parameters, as generated by process_parameters.py", 
    type=str,
    required=True)
parser.add_argument("--snps",
    help="Output vcf file for simulated SNPs, can be .gz ",
    type=str, 
    required=False)
parser.add_argument("--indels",
    help="Output vcf file for simulated indels, can be .gz ",
    type=str, 
    required=False)

args = parser.parse_args()

# Validate input arguments
if not os.path.exists(args.infile):
    logging.error(f"Reference genome fasta file '{args.infile}' does not exist.")
    sys.exit(1)
if not os.path.exists(args.infile + ".fai"):
    logging.error(f"Fasta index file '{args.infile}.fai' does not exist.")
    sys.exit(1)
if not os.path.exists(args.pickle):
    logging.error(f"Pickle file '{args.pickle}' does not exist.")
    sys.exit(1)

NUCLEOTIDES = ["A", "C", "G", "T"]

# python's randomizer is expected to be reproducible with the same seed and
# when using the same version. However having the exact same pseudo-random
# values for each position regardless of chromosome is undesirable.
# Therefore the chromosome is used as the seed, so they each have different
# pseudo-random values.
random.seed(args.chrom, version=2)


def read_fasta_index(filename: str) -> dict:
    """
    Reads fasta.fai index from file
    :param filename: filename of index to read
    :return: Dict sequence name, list of sequence statistics
    """
    res = {}
    with open(filename) as infile:
        for line in infile:
            fields = line.split()
            if len(fields) == 5:
                cname, length, start, line, cline = fields
                res[cname] = int(length), int(start), int(line), int(cline)
            else:
                logging.error(f'Unexpected line in fasta index file: {line.strip()}')
                sys.exit(1)
    return res

def open_vcf(filename: str):
    """
    Open a file and write vcf header to it
    :param filename: str, filename and path
    :return: file handle
    """
    out_f = gzip.open(filename, 'wt') if filename.endswith(".gz") else open(filename, 'w')
    vcf_header = (
        '##fileformat=VCFv4.1\n'
        '##INFO=<ID=CpG,Number=0,Type=Flag,Description="Position was mutated in a CpG dinucleotide context (based on the reference sequence).">\n'
        '#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n'
    )
    out_f.write(vcf_header)
    return out_f

def get_base(b_pos: int) -> str:
    """
    Get a specific base at position b_pos from the mapped reference file
    :param b_pos: int, position to fetch base for.
    :return: str of length 1 with desired position, error if outside file.
    """
    npos = (b_pos // bline) * cline + (b_pos % bline)
    cmap.seek(sblock + npos)
    return cmap.read(1).decode("utf-8").upper()

if args.snps is None and args.indels is None:
    sys.exit(f"No target: Define the snp and/or indel output file.")

# PARSE GENOME FILE(s)
if not os.path.exists(args.infile) or not os.path.exists(
        args.infile + ".fai"):
    sys.stderr.write("Invalid path for genome and genome fasta index file.\n")
    sys.exit()

fastaindex = read_fasta_index(args.infile + ".fai")
if len(fastaindex) != 1:
    sys.exit(f"Reference genome fasta is expected to contain 1 sequence, "
             f"not {len(fastaindex)}")

# OPEN FASTA COPY WITH MMAP
logging.info('Doing mmap of genome file...')
try:
    with open(args.infile, "r") as f:
        cmap = mmap.mmap(f.fileno(), length=0, access=mmap.ACCESS_READ)
        cmap.flush()
except Exception as e:
    logging.error(f"Error opening or memory-mapping the genome file: {e}")
    sys.exit(1)

logging.info('Loading parameters from pickle file...')
try:
    with open(args.pickle, "rb") as pickle_f:
        intervals, interval_vals, gmut, dmut, gmutCpG, dmutCpG, gdeletions, ginserts, \
        dmutindel, GTR_CpG, GTR_nonCpG, deletions, inserts = pickle.load(pickle_f)
except Exception as e:
    logging.error(f"Error loading parameters from pickle file: {e}")
    sys.exit(1)

sys.stderr.write('Iterating over genome...\n')
# SIMULATE VARIANTS, PRINT TO VCF OUTPUT
snp_out, indel_out = None, None
if args.snps is not None:
    snp_out = open_vcf(args.snps)
if args.indels is not None:
    indel_out = open_vcf(args.indels)
to_sort = list(intervals.keys())
to_sort.sort()

length, sblock, bline, cline = next(iter(fastaindex.values()))
cintervals = intervals[args.chrom]
cintervals.sort()
sys.stderr.write("Simulating variants on chrom\t%s\n" % args.chrom)
N = len(cintervals)

for ind, (start, end) in enumerate(cintervals):
    wmut, wmutCpG, wtotal, wtotalCpG, wA, wC, wG, wT = 0, 0, 0, 0, 0, 0, 0, 0
    for neighbors in range(
            max(0, ind - 5 - max(ind + 6 - len(cintervals), 0)),
            min(len(cintervals), ind + 6 - min(0, ind - 5))):
        pos1, pos2 = cintervals[neighbors]
        (cmut, ctotal, cmutCpG, ctotalCpG, cA, cC, cG, cT) = \
            interval_vals[(args.chrom, pos1, pos2)]
        wmut += cmut
        wtotal += ctotal
        wmutCpG += cmutCpG
        wtotalCpG += ctotalCpG
        wA += cA
        wC += cC
        wG += cG
        wT += cT
    if wtotal == 0:
        sys.stderr.write(
            'Encountered genomic blocks without any non-N bases. Skipping.\n')
        continue

    tbases = float(wA + wC + wG + wT)
    bfreqs = [wA / tbases, wC / tbases, wG / tbases, wT / tbases]
    if wtotal > 1000:
        y = wmut / float(wtotal)
    else:
        y = gmut
    if wtotalCpG > 1000:
        yCpG = wmutCpG / float(wtotalCpG)
    else:
        yCpG = gmutCpG
    # print bfreqs,y,yCpG

    # dmut, gmut, gdeletions (deletions), ginserts (inserts)
    lmut = y / gmut * dmut
    lmutGpG = yCpG / gmutCpG * dmutCpG
    ldeletion = y / gmut * gdeletions / gmut * dmutindel
    linsertion = y / gmut * ginserts / gmut * dmutindel

    if not end + 1 <= length:
        end = length - 1
    if not start > 1:
        start = 2

    lbase, base, nbase = None, None, None
    for pos in range(start, end):
        if pos % 10000000 == 0:
            sys.stderr.write(f"Currently on chr{args.chrom}-{pos/1000000}\n")

        # Simulate SNPs if desired
        if snp_out:

            if lbase is not None:
                lbase, base = base, nbase
                nbase = get_base(pos)
            else:
                lbase = get_base(pos - 2)
                base = get_base(pos - 1)
                nbase = get_base(pos)

            ismut = random.random()
            if (base == "C" and nbase == "G") or \
                    (base == "G" and lbase == "C"):
                if ismut <= lmutGpG:
                    whichmut = random.random()
                    for i, alt in enumerate(NUCLEOTIDES):
                        if alt != base:
                            whichmut -= GTR_CpG[base][i]
                            if whichmut < 0:
                                snp_out.write(
                                    "%s\t%d\t.\t%s\t%s\t.\t.\tCpG\n" % (
                                        args.chrom, pos, base, alt))
                                break
            elif base in NUCLEOTIDES:
                if ismut <= lmut:
                    whichmut = random.random()
                    for i, alt in enumerate(NUCLEOTIDES):
                        if alt != base:
                            whichmut -= GTR_nonCpG[base][i]
                            if whichmut < 0:
                                snp_out.write(
                                    "%s\t%d\t.\t%s\t%s\t.\t.\t.\n" % (
                                        args.chrom, pos, base, alt))
                                break
            else:
                # sys.stderr.write("Base %s on %s %d can not be mutated.
                # Skipping.\n"%(base,chrom,pos))
                continue

        # Only simulate indels if called for
        if not indel_out:
            continue

        isindel = random.random()
        if isindel <= ldeletion:
            base = get_base(pos - 1)
            if base not in NUCLEOTIDES:
                continue

            indellength = random.random()
            for dellength, value in deletions:
                indellength -= value
                if indellength <= 0:
                    delseq = ''
                    for i in range(dellength):
                        if pos + i < length:
                            delseq += get_base(pos + i)
                        else:
                            break
                    if len(delseq) == dellength:
                        indel_out.write(
                            "%s\t%d\t.\t%s\t%s\t.\t.\t.\n" % (
                                args.chrom, pos, base + delseq, base))
                    break

        isindel = random.random()
        if isindel <= linsertion:
            base = get_base(pos - 1)
            if base not in NUCLEOTIDES:
                continue

            indellength = random.random()
            for inslength, value in inserts:
                indellength -= value
                if indellength <= 0:
                    insseq = ""
                    for s in range(inslength):
                        whichbase = random.random()
                        for i, newbase in enumerate(NUCLEOTIDES):
                            whichbase -= bfreqs[i]
                            if whichbase <= 0:
                                insseq += newbase
                                break
                    indel_out.write(
                        "%s\t%d\t.\t%s\t%s\t.\t.\t.\n" % (
                            args.chrom, pos, base, base + insseq))
                    break
if snp_out:
    snp_out.close()
if indel_out:
    indel_out.close()
cmap.close()

logging.info("Simulation completed successfully.")